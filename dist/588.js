"use strict";(self.webpackChunkvolumetric_atmospheric_scattering=self.webpackChunkvolumetric_atmospheric_scattering||[]).push([[588],{5312:(e,t,r)=>{var a=r(6367),n=r(6293),o=r(7530),s=r(2228);a.w.prototype._createDepthStencilCubeTexture=function(e,t){const r=new n.h(this,12);if(r.isCube=!0,1===this.webGLVersion)return o.V.Error("Depth cube texture is not supported by WebGL 1."),r;const a={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...t},s=this._gl;this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,r,!0),this._setupDepthStencilTexture(r,e,a.generateStencil,a.bilinearFiltering,a.comparisonFunction);for(let t=0;t<6;t++)a.generateStencil?s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,s.DEPTH24_STENCIL8,e,e,0,s.DEPTH_STENCIL,s.UNSIGNED_INT_24_8,null):s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,s.DEPTH_COMPONENT24,e,e,0,s.DEPTH_COMPONENT,s.UNSIGNED_INT,null);return this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,null),this._internalTexturesCache.push(r),r},a.w.prototype._setCubeMapTextureParams=function(e,t,r){const a=this._gl;a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_MIN_FILTER,t?a.LINEAR_MIPMAP_LINEAR:a.LINEAR),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),e.samplingMode=t?3:2,t&&this.getCaps().textureMaxLevel&&void 0!==r&&r>0&&(a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_MAX_LEVEL,r),e._maxLodLevel=r),this._bindTextureDirectly(a.TEXTURE_CUBE_MAP,null)},a.w.prototype.createCubeTexture=function(e,t,r,a,n=null,i=null,l,u=null,f=!1,_=0,c=0,p=null,h,A=!1,d=null){const C=this._gl;return this.createCubeTextureBase(e,t,r,!!a,n,i,l,u,f,_,c,p,(e=>this._bindTextureDirectly(C.TEXTURE_CUBE_MAP,e,!0)),((e,t)=>{const r=this.needPOTTextures?(0,s.R)(t[0].width,this._caps.maxCubemapTextureSize):t[0].width,i=r,u=[C.TEXTURE_CUBE_MAP_POSITIVE_X,C.TEXTURE_CUBE_MAP_POSITIVE_Y,C.TEXTURE_CUBE_MAP_POSITIVE_Z,C.TEXTURE_CUBE_MAP_NEGATIVE_X,C.TEXTURE_CUBE_MAP_NEGATIVE_Y,C.TEXTURE_CUBE_MAP_NEGATIVE_Z];this._bindTextureDirectly(C.TEXTURE_CUBE_MAP,e,!0),this._unpackFlipY(!1);const f=l?this._getInternalFormat(l,e._useSRGBBuffer):e._useSRGBBuffer?this._glSRGBExtensionValues.SRGB8_ALPHA8:C.RGBA;let _=l?this._getInternalFormat(l):C.RGBA;e._useSRGBBuffer&&1===this.webGLVersion&&(_=f);for(let e=0;e<u.length;e++)if(t[e].width!==r||t[e].height!==i){if(this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext)return void o.V.Warn("Cannot create canvas to resize texture.");this._workingCanvas.width=r,this._workingCanvas.height=i,this._workingContext.drawImage(t[e],0,0,t[e].width,t[e].height,0,0,r,i),C.texImage2D(u[e],0,f,_,C.UNSIGNED_BYTE,this._workingCanvas)}else C.texImage2D(u[e],0,f,_,C.UNSIGNED_BYTE,t[e]);a||C.generateMipmap(C.TEXTURE_CUBE_MAP),this._setCubeMapTextureParams(e,!a),e.width=r,e.height=i,e.isReady=!0,l&&(e.format=l),e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),n&&n()}),!!A,d)},a.w.prototype.generateMipMapsForCubemap=function(e,t=!0){if(e.generateMipMaps){const r=this._gl;this._bindTextureDirectly(r.TEXTURE_CUBE_MAP,e,!0),r.generateMipmap(r.TEXTURE_CUBE_MAP),t&&this._bindTextureDirectly(r.TEXTURE_CUBE_MAP,null)}}},6588:(e,t,r)=>{r.r(t),r.d(t,{_DDSTextureLoader:()=>y});var a=r(9026),n=r(847),o=r(7530),s=r(8894),i=r(4935),l=r(6293),u=r(2928),f=r(9415),_=r(3924),c=r(9169);_.$.prototype._partialLoadFile=function(e,t,r,a,n=null){this._loadFile(e,(e=>{r[t]=e,r._internalCount++,6===r._internalCount&&a(r)}),void 0,void 0,!0,((e,t)=>{n&&e&&n(e.status+" "+e.statusText,t)}))},_.$.prototype._cascadeLoadFiles=function(e,t,r,a=null){const n=[];n._internalCount=0;for(let e=0;e<6;e++)this._partialLoadFile(r[e],e,n,t,a)},_.$.prototype._cascadeLoadImgs=function(e,t,r,a,n=null,o){const s=[];s._internalCount=0;for(let i=0;i<6;i++)this._partialLoadImg(a[i],i,s,e,t,r,n,o)},_.$.prototype._partialLoadImg=function(e,t,r,a,n,o,s=null,i){const l=(0,f.z)();(0,u.W$)(e,(e=>{r[t]=e,r._internalCount++,a&&a.removePendingData(l),6===r._internalCount&&o&&o(n,r)}),((e,t)=>{a&&a.removePendingData(l),s&&s(e,t)}),a?a.offlineProvider:null,i),a&&a.addPendingData(l)},_.$.prototype.createCubeTextureBase=function(e,t,r,a,n=null,s=null,i,u=null,f=!1,_=0,p=0,h=null,A=null,d=null,C=!1,E=null){const T=h||new l.h(this,7);T.isCube=!0,T.url=e,T.generateMipMaps=!a,T._lodGenerationScale=_,T._lodGenerationOffset=p,T._useSRGBBuffer=!!C&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!a),T!==h&&(T.label=e.substring(0,60)),this._doNotHandleContextLost||(T._extension=u,T._files=r,T._buffer=E);const m=e;this._transformTextureUrl&&!h&&(e=this._transformTextureUrl(e));const y=e.split("?")[0],B=y.lastIndexOf("."),b=u||(B>-1?y.substring(B).toLowerCase():""),g=(0,c.g)(b),G=(l,c)=>{e===m?s&&l&&s(l.status+" "+l.statusText,c):(o.V.Warn(`Failed to load ${e}, falling back to the ${m}`),this.createCubeTextureBase(m,t,r,!!a,n,s,i,u,f,_,p,T,A,d,C,E))};if(g)g.then((a=>{const i=e=>{A&&A(T,e),a.loadCubeData(e,T,f,n,s)};E?i(E):r&&6===r.length?a.supportCascades?this._cascadeLoadFiles(t,(e=>i(e.map((e=>new Uint8Array(e))))),r,s):s?s("Textures type does not support cascades."):o.V.Warn("Texture loader does not support cascades."):this._loadFile(e,(e=>i(new Uint8Array(e))),void 0,void 0,!0,G)}));else{if(!r||0===r.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(t,T,((e,t)=>{d&&d(e,t)}),r,s)}return this._internalTexturesCache.push(T),T},r(5312);const p=131072,h=131072;function A(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}const d=A("DXT1"),C=A("DXT3"),E=A("DXT5"),T=A("DX10");class m{static GetDDSInfo(e){const t=new Int32Array(e.buffer,e.byteOffset,31),r=new Int32Array(e.buffer,e.byteOffset,35);let a=1;t[2]&p&&(a=Math.max(1,t[7]));const n=t[21],o=n===T?r[32]:0;let s=0;switch(n){case 113:s=2;break;case 116:s=1;break;case T:if(10===o){s=2;break}if(2===o){s=1;break}}return{width:t[4],height:t[3],mipmapCount:a,isFourCC:!(4&~t[20]),isRGB:!(64&~t[20]),isLuminance:(t[20]&h)===h,isCube:!(512&~t[28]),isCompressed:n===d||n===C||n===E,dxgiFormat:o,textureType:s}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,t,r,a,n,o){const s=new Float32Array(a),l=new Uint16Array(n,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);s[u]=(0,i.SX)(l[a]),s[u+1]=(0,i.SX)(l[a+1]),s[u+2]=(0,i.SX)(l[a+2]),m.StoreLODInAlphaChannel?s[u+3]=o:s[u+3]=(0,i.SX)(l[a+3]),u+=4}return s}static _GetHalfFloatRGBAArrayBuffer(e,t,r,a,n,o){if(m.StoreLODInAlphaChannel){const s=new Uint16Array(a),l=new Uint16Array(n,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);s[u]=l[a],s[u+1]=l[a+1],s[u+2]=l[a+2],s[u+3]=(0,i.LZ)(o),u+=4}return s}return new Uint16Array(n,r,a)}static _GetFloatRGBAArrayBuffer(e,t,r,a,n,o){if(m.StoreLODInAlphaChannel){const s=new Float32Array(a),i=new Float32Array(n,r);let l=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);s[l]=i[a],s[l+1]=i[a+1],s[l+2]=i[a+2],s[l+3]=o,l+=4}return s}return new Float32Array(n,r,a)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,t,r,a,n,o){const s=new Uint16Array(a),l=new Float32Array(n,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++)s[u]=(0,i.LZ)(l[u]),s[u+1]=(0,i.LZ)(l[u+1]),s[u+2]=(0,i.LZ)(l[u+2]),m.StoreLODInAlphaChannel?s[u+3]=(0,i.LZ)(o):s[u+3]=(0,i.LZ)(l[u+3]),u+=4;return s}static _GetFloatAsUIntRGBAArrayBuffer(e,t,r,a,o,s){const i=new Uint8Array(a),l=new Float32Array(o,r);let u=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);i[u]=255*n.X.Clamp(l[a]),i[u+1]=255*n.X.Clamp(l[a+1]),i[u+2]=255*n.X.Clamp(l[a+2]),m.StoreLODInAlphaChannel?i[u+3]=s:i[u+3]=255*n.X.Clamp(l[a+3]),u+=4}return i}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,t,r,a,o,s){const l=new Uint8Array(a),u=new Uint16Array(o,r);let f=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);l[f]=255*n.X.Clamp((0,i.SX)(u[a])),l[f+1]=255*n.X.Clamp((0,i.SX)(u[a+1])),l[f+2]=255*n.X.Clamp((0,i.SX)(u[a+2])),m.StoreLODInAlphaChannel?l[f+3]=s:l[f+3]=255*n.X.Clamp((0,i.SX)(u[a+3])),f+=4}return l}static _GetRGBAArrayBuffer(e,t,r,a,n,o,s,i,l){const u=new Uint8Array(a),f=new Uint8Array(n,r);let _=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=4*(t+r*e);u[_]=f[a+o],u[_+1]=f[a+s],u[_+2]=f[a+i],u[_+3]=f[a+l],_+=4}return u}static _ExtractLongWordOrder(e){return 0===e||255===e||-16777216===e?0:1+m._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,t,r,a,n,o,s,i){const l=new Uint8Array(a),u=new Uint8Array(n,r);let f=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=3*(t+r*e);l[f]=u[a+o],l[f+1]=u[a+s],l[f+2]=u[a+i],f+=3}return l}static _GetLuminanceArrayBuffer(e,t,r,a,n){const o=new Uint8Array(a),s=new Uint8Array(n,r);let i=0;for(let r=0;r<t;r++)for(let t=0;t<e;t++){const a=t+r*e;o[i]=s[a],i++}return o}static UploadDDSLevels(e,t,r,a,n,i,l=-1,u,f=!0){let _=null;a.sphericalPolynomial&&(_=[]);const c=!!e.getCaps().s3tc;t.generateMipMaps=n;const h=new Int32Array(r.buffer,r.byteOffset,31);let A,y,B,b,g,G,U,R=0,x=0,F=1;if(542327876!==h[0])return void o.V.Error("Invalid magic number in DDS header");if(!a.isFourCC&&!a.isRGB&&!a.isLuminance)return void o.V.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(a.isCompressed&&!c)return void o.V.Error("Compressed textures are not supported on this platform.");let D=h[22];b=h[1]+4;let w=!1;if(a.isFourCC)switch(A=h[21],A){case d:F=8,x=33777;break;case C:F=16,x=33778;break;case E:F=16,x=33779;break;case 113:w=!0,D=64;break;case 116:w=!0,D=128;break;case T:{b+=20;let e=!1;switch(a.dxgiFormat){case 10:w=!0,D=64,e=!0;break;case 2:w=!0,D=128,e=!0;break;case 88:a.isRGB=!0,a.isFourCC=!1,D=32,e=!0}if(e)break}default:return void o.V.Error(["Unsupported FourCC code:",(L=A,String.fromCharCode(255&L,L>>8&255,L>>16&255,L>>24&255))])}var L;const M=m._ExtractLongWordOrder(h[23]),I=m._ExtractLongWordOrder(h[24]),P=m._ExtractLongWordOrder(h[25]),S=m._ExtractLongWordOrder(h[26]);w&&(x=e._getRGBABufferInternalSizedFormat(a.textureType)),G=1,h[2]&p&&!1!==n&&(G=Math.max(1,h[7]));const X=u||0,O=e.getCaps();for(let n=X;n<i;n++){for(y=h[4],B=h[3],U=0;U<G;++U){if(-1===l||l===U){const o=-1===l?U:0;if(!a.isCompressed&&a.isFourCC){t.format=5,R=y*B*4;let a=null;if(e._badOS||e._badDesktopOS||!O.textureHalfFloat&&!O.textureFloat)128===D?(a=m._GetFloatAsUIntRGBAArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,o),_&&0==o&&_.push(m._GetFloatRGBAArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,o))):64===D&&(a=m._GetHalfFloatAsUIntRGBAArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,o),_&&0==o&&_.push(m._GetHalfFloatAsFloatRGBAArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,o))),t.type=0;else{const e=O.textureFloat&&(f&&O.textureFloatLinearFiltering||!f),n=O.textureHalfFloat&&(f&&O.textureHalfFloatLinearFiltering||!f),s=(128===D||64===D&&!n)&&e?1:(64===D||128===D&&!e)&&n?2:0;let i,l=null;if(128===D)switch(s){case 1:i=m._GetFloatRGBAArrayBuffer,l=null;break;case 2:i=m._GetFloatAsHalfFloatRGBAArrayBuffer,l=m._GetFloatRGBAArrayBuffer;break;case 0:i=m._GetFloatAsUIntRGBAArrayBuffer,l=m._GetFloatRGBAArrayBuffer}else switch(s){case 1:i=m._GetHalfFloatAsFloatRGBAArrayBuffer,l=null;break;case 2:i=m._GetHalfFloatRGBAArrayBuffer,l=m._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:i=m._GetHalfFloatAsUIntRGBAArrayBuffer,l=m._GetHalfFloatAsFloatRGBAArrayBuffer}t.type=s,a=i(y,B,r.byteOffset+b,R,r.buffer,o),_&&0==o&&_.push(l?l(y,B,r.byteOffset+b,R,r.buffer,o):a)}a&&e._uploadDataToTextureDirectly(t,a,n,o)}else if(a.isRGB)t.type=0,24===D?(t.format=4,R=y*B*3,g=m._GetRGBArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,M,I,P),e._uploadDataToTextureDirectly(t,g,n,o)):(t.format=5,R=y*B*4,g=m._GetRGBAArrayBuffer(y,B,r.byteOffset+b,R,r.buffer,M,I,P,S),e._uploadDataToTextureDirectly(t,g,n,o));else if(a.isLuminance){const a=e._getUnpackAlignement(),s=y;R=Math.floor((y+a-1)/a)*a*(B-1)+s,g=m._GetLuminanceArrayBuffer(y,B,r.byteOffset+b,R,r.buffer),t.format=1,t.type=0,e._uploadDataToTextureDirectly(t,g,n,o)}else R=Math.max(4,y)/4*Math.max(4,B)/4*F,g=new Uint8Array(r.buffer,r.byteOffset+b,R),t.type=0,e._uploadCompressedDataToTextureDirectly(t,x,y,B,g,n,o)}b+=D?y*B*(D/8):R,y*=.5,B*=.5,y=Math.max(1,y),B=Math.max(1,B)}if(void 0!==u)break}_&&_.length>0?a.sphericalPolynomial=s.d.ConvertCubeMapToSphericalPolynomial({size:h[4],right:_[0],left:_[1],up:_[2],down:_[3],front:_[4],back:_[5],format:5,type:1,gammaSpace:!1}):a.sphericalPolynomial=void 0}}m.StoreLODInAlphaChannel=!1;class y{constructor(){this.supportCascades=!0}loadCubeData(e,t,r,n){const o=t.getEngine();let s,i=!1,l=1e3;if(Array.isArray(e))for(let r=0;r<e.length;r++){const a=e[r];s=m.GetDDSInfo(a),t.width=s.width,t.height=s.height,i=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&t.generateMipMaps,o._unpackFlipY(s.isCompressed),m.UploadDDSLevels(o,t,a,s,i,6,-1,r),s.isFourCC||1!==s.mipmapCount?l=s.mipmapCount-1:o.generateMipMapsForCubemap(t)}else{const n=e;s=m.GetDDSInfo(n),t.width=s.width,t.height=s.height,r&&(s.sphericalPolynomial=new a.Q),i=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&t.generateMipMaps,o._unpackFlipY(s.isCompressed),m.UploadDDSLevels(o,t,n,s,i,6),s.isFourCC||1!==s.mipmapCount?l=s.mipmapCount-1:o.generateMipMapsForCubemap(t,!1)}o._setCubeMapTextureParams(t,i,l),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),n&&n({isDDS:!0,width:t.width,info:s,data:e,texture:t})}loadData(e,t,r){const a=m.GetDDSInfo(e),n=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&t.generateMipMaps&&Math.max(a.width,a.height)>>a.mipmapCount-1==1;r(a.width,a.height,n,a.isFourCC,(()=>{m.UploadDDSLevels(t.getEngine(),t,e,a,n,1)}))}}}}]);